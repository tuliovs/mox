'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = memoize;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var sentinel = Symbol('Cache key for `memoize` corresponding to the cached value for a complete set of arguments');

/**
 * Get a value from the given cache Map, accessing an inner Map for each value in `keys`.
 * If a value does not exist, return undefined.
 * @param  {Map}        cache The base Map from which to get a value
 * @param  {Array<Any>} keys  An array of keys for which nested Maps will be accessed
 * @return {Any}        The value itself
 */
function get(cache, keys) {
  if (keys.length === 0) {
    return cache.get(sentinel);
  }

  var _keys = _toArray(keys);

  var key = _keys[0];

  var restKeys = _keys.slice(1);

  var nestedCache = cache.get(key);
  if (!nestedCache) {
    return undefined;
  }
  return get(nestedCache, restKeys);
}

/**
 * Set a value in the given cache Map, creating a new nested Map
 * (or using an existing Map) for each value in `keys`.
 * The innermost Map will have `map.get(sentinel) === value`.
 * @param {Map}        cache The base Map for which to set a value
 * @param {Array<Any>} keys  An array of keys for which new nested Maps will be created/used
 * @param {Any}        value The value to set in the cache
 */
function set(cache, keys, value) {
  if (keys.length === 0) {
    cache.set(sentinel, value);
  } else {
    var _keys2 = _toArray(keys);

    var key = _keys2[0];

    var restKeys = _keys2.slice(1);

    var nestedCache = cache.get(key);
    if (!nestedCache) {
      nestedCache = new Map();
      cache.set(key, nestedCache);
    }
    set(nestedCache, restKeys, value);
  }
  return value;
}

function memoizeAsync(fn, _ref) {
  var arity = _ref.arity;
  var immediate = _ref.immediate;

  var cache = new Map();
  return function memoized() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var fnArgs = args.slice(0, -1);
    var callback = args[args.length - 1];
    var cacheArgs = arity !== undefined ? fnArgs.slice(0, arity) : fnArgs;
    var cached = get(cache, cacheArgs);
    if (cached) {
      if (immediate) {
        callback(null, cached);
        return;
      }
      setImmediate(function () {
        return callback(null, cached);
      });
      return;
    }
    fn.apply(undefined, _toConsumableArray(fnArgs).concat([function (error, result) {
      if (!error) {
        set(cache, cacheArgs, result);
      }
      callback(error, result);
    }]));
  };
}

/**
 * Memoize the given function by the identity of its arguments.
 * @param  {Function}       fn
 *   The function to memoize
 * @param  {Object}         [options]
 *   Options
 * @param  {Number}         [options.arity]
 *   The number of arguments to memoize by. If undefined, all arguments will be used.
 * @param  {Boolean|String} [options.async]
 *   Pass `true` if fn is a Node-style asynchronous function: results passed to the final
 *   callback argument will be cached and provided asynchronously
 *   (via `setImmediate`) to subsequent calls.
 *   Pass 'immediate' to call the callback immediately for subsequent calls.
 *   If an error is returned (as the first argument to the callback), the result
 *   will not be cached.
 * @return {Function}
 *   The memoized function
 */
function memoize(fn) {
  var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var arity = _ref2.arity;
  var async = _ref2.async;

  if (async) {
    return memoizeAsync(fn, { arity: arity, immediate: async === 'immediate' });
  }
  var cache = new Map();
  return function memoized() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var cacheArgs = arity !== undefined ? args.slice(0, arity) : args;
    return get(cache, cacheArgs) || set(cache, cacheArgs, fn.apply(undefined, args));
  };
}